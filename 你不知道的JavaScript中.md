#### 第一章 类型

#### 1.内置对象

 	1. typeof null 是 object 原因是上册中记录过的 null 的二进制全是0 而判断object的前三为0
		2. （!a && typeof a  ===  "object"）
		3.  函数就是可调用对象 是object的子类型 特别的是 typeof 函数 返回的是 function 
		4. 函数有一个内部属性[[Call]] 该属性可以被调用

#### 2.值与类型

   1.变量是没有类型的, 只有值才有 所以typeof一个变量时 得到的也是该变量持有的值的类型 

2. typeof有安全机制 定义了未赋值的变量返回 undefined 未定义的变量 使用typeof 也是undefined



### 第二章 值

#### 2.1 数组

1.Array.prototype.slice.call(arguments) 和 Array.from(args) (ES6的) 都能实现把伪数组转为真正的数组

#### 2.2 字符串

1.字符串是不可变的 a[2] 这样取是不合适的 使用 a.charAt(2) 最正确

2.虽然字符串能借用很多数组的方法 但有一个是字符串没有的就是反转 reverse() 常用的解决办法就是先转为数组反转后再转为字符串

#### 2.3 数字

1. .toFixed() 可以指定显示小数的位数 但是有一种需要注意的情况

   例 42.toFixed(3) 会报错 因为 42后面的点会优先识别为数字字面量的一部分

   虽然这种情况少见但是也需要了解 正确的写法是 42..toFixed(3) 

   神奇的是 42 .toFixed(3) 也可以 （注意有个空格）

2. ES6开始 严格模式不支持0363八进制格式 得用0o363 o可以大写但是不建议

3. 0.1+0.2 === 0.3 false 是因为二进制浮点数中 加起来是 0.30000000000000004

4. ES6 开始 在 Number.EPSILON 中放了一个机器精度 可以把 0.1 +0.2的值和0.3相减或相加

   然后用Math.abs 取绝对值 看是否小于这个精度 小于就可以看做相等

   当然 也可以把 0.1 和 0.2 变成整数运算后再除回去

5. ES6 中 能被安全呈现的最大整数是 2^53 - 1 被定义为 Number.MAX_SFAE_INTEGER

   最小的是 - ( 2^53 - 1） 被定义为 Number.MIN_SFAE_INTEGER

   所以js里无法精准呈现64位数值

6.  表达式 void xxxxx   没有返回值 因此返回的是undefined 习惯性用的是 void 0 

7. NaN 是一个警戒值 用于表述 数学运算未成功,这是失败返回的结果

8. 判断一个值是不是 NaN 直接让值与它自身相比 false 就是 NaN(上卷记载过)

9. 计算结果溢出就会是 Infinity  如果有一个操作数为负数 就是 -Infinity  

10. Infinity  / Infinity  是未定义操作 返回 NaN

11. 有穷整数除以 Infinity  是 0，有穷负数除以Infinity  是 -0

12. 加法和减法运算不会产生 -0 -0字符串化会变0 字符串-0转数字是正常的

13. ES6 新增 Object.is() 可以判断两个值是否绝对相等 但能使用 == 和 === 就不要用 is 因为前者效率高

    ​


#### 2.5 值和引用

1.简单值总是通过值复制的方式来赋值 包括 null undefined 字符串 数字 布尔和 symbol

[^时间]: 2018年7月24日00:20:39







