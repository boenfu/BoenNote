### 第一部分 作用域与闭包

#### 1.作用域是什么

0.我们将作用域定义为一套规则

1.大部分情况下，编译发生在代码执行前的几微秒（甚至更短）

2.引擎搜索有 LHS 和 RHS， 最好理解为 赋值操作的目标是谁 和 谁是赋值操作的源头

3.RHS未搜索到 引擎会抛出 ReferenceError 异常

4.非严格模式下 LHS 未找到会自动创建并返回一个全局变量 而严格模式下也会抛出 ReferenceError 异常

5.对 RHS 找到的变量进行不合理的操作时 会抛出 TypeError



#### 2.词法作用域

1.让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践

2.词法作用域只会找一级标识符 如 foo.bar.baz 词法作用域只会找 foo 找到后

​	对象属性访问规则会分别接管对 bar 和 baz 的访问

3.欺骗词法作用域会导致性能下降 因为引擎无法在编译时对作用域查找进行优化

4.eval('字符串') 会让其中的内容视为书写时就存在当前位置的，尽管内容可能是动态获取的

5.严格模式中 eval 有自己的词法作用域 所以无法修改书写期的词法作用域

6.eval如果接受了含有声明的代码，就会修改所处的词法作用域

​	但 with 会根据你传给他的对象凭空创建一个全新的词法作用域

7.尽管 with块 会将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中

​	而是被添加到with所处的函数作用域中

8.严格模式下 with 被完全禁止了



#### 3.函数作用域和块作用域

1.作用域的隐藏变量及函数的方法，大多都是从最小暴露原则中引申出来的

2.如果 function 在整个声明中的位置是第一个词 那么就是一个函数声明 否则是一个函数表达式

3.函数声明和函数表达式之间最重要的区别就是他们的名称标识符绑定的位置不同

​	函数声明被绑定在所处的作用域中

​	函数表达式如(function foo(){..}) 意味着foo只能在 .. 所代表的位置中进行访问

4.函数表达式是可以匿名的 如 setTimeout 的参数，而函数声明是不可以省略函数名的

5.始终给函数表达式命名是一个最佳实践

6.(function foo(){..}) () 有个专业的术语叫 IIFE --代表 立即执行函数表达式

​	(function foo(){..}()) 也行 功能上完全一致

7.with也是块级作用域的一种形式

8.try/catch 的catch分支也会创建一个块级作用域



#### 4.提升

1.只有声明本身会被提升，而赋值或其他运行逻辑会留在原地

2.每个作用域都会被提升

3.函数声明会被提升，而函数表达式不会

4.函数的声明会被提升到普通变量之前，重复声明的普通变量就会被忽略掉



#### 5.作用域闭包

0.闭包是基于词法作用域书写代码时产生的自然结构

1.函数在定义时的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域

2.在定时器，事件监听器，ajax请求，跨窗口通信，web worker 或其他异步(或同步)任务中，只要使用了回调函数 实际就是在使用闭包

3.IIFE是最常用来创建可以被封闭起来的闭包的工具，但其本身并不会真的使用闭包

4.模块模式的其中两个特点 

​	为函数引入包装函数

​	保证他的返回值和模块的api保持一致

5.当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行的，这时候就产生了闭包



#### 附录A 动态作用域

1.动态作用域不关心函数和作用域是如何声明以及在何处声明的，只关心他们从何处调用

换句话说 作用域链是基于调用栈的，而不是代码中的作用域嵌套

2.JavaScript不具有动态作用域，但是this机制某种程度上很像动态作用域



### 第二部分 this和对象原型

#### 1.关于this

[^任何足够先进的技术都和魔法无异 —— Arthur C.Clarke]: 

1.随着使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用this则不会

2.使用arguments.callee 是唯一一种可以从匿名函数对象内部引用自身的方法，但已经被弃用了

3.this在任何情况下都不指向函数的词法作用域，作用域“对象”无法通过js代码访问，他存在于引擎的内部

4.this是运行时绑定的，并不是在编写时绑定的，上下文取决于函数调用时的各种条件

5.this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式



#### 2.this全面解析

1.分析出函数的真正调用位置，有助于找到this的绑定对象

2.声明在全局作用域的变量就是全局对象的一个同名属性

3.4种绑定规则之一：隐式绑定

​	当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象引用属性链只有最后一层会影响到调用位置

​	隐式丢失就是被隐式绑定的函数丢失绑定对象，从而只能应用默认绑定的现象，例如传入传入回调函数时，回调函数是一个对象的属性，因为参数传递实际是一种隐式赋值，因此传入函数时也会被隐式赋值，所以回调函数的this就不指向之前引用他的对象了

4.显示绑定  call() 和 apply() 方法

​	bind() 也可以，bind 返回的是一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数，可以理解为bind内部实现时用了call或者apply，连续多次的bind是无效的

5.new绑定

​	实际上不存在所谓的构造函数，只有对函数的构造调用

​	new 调用函数时，会执行四步

​		1.创建一个全新的对象

​		2.新对象会被执行原型连接

​		3.新对象会绑定到函数调用的this

​		4.如果函数没有返回其他对象，new表达式中的函数调用会自动返回这个新对象

​	用 new 来调用 一个函数，会构造出一个新对象并且把他绑定到函数的this上，这种this绑定方式就是new绑定

[^2018年7月19日17:39:29 新增笔记1]: 对函数的构造调用其实就是执行一次函数 把执行造成的结果放入新增的对象里面
[^2]: new的右边是一个函数对象 而得到的就是一个普通对象 见后面原型的代码

6.无法应用其他绑定规则时就会使用默认绑定

​	独立的函数调用时，就是使用的默认绑定，this就指向全局对象，严格模式下会绑定到undefined

​	这里是严格模式是指的函数体，并不是调用位置是否是严格模式，当然全局统一是否使用严格模式是最好的实践

7.优先级判断顺序是

​	new 显示 隐式 默认

8.例外

​	把null或者undefined作为this的绑定对象传入call，apply或bind的话，会被忽略并调用默认绑定

​	间接引用也会应用默认绑定，就像隐式丢失那种

9.箭头函数不使用this的四种规则，是根据外层作用域来决定的this

​	箭头函数的绑定无法被修改

#### 3.对象

1.null之所以会被当做一种对象类型，是因为js中二进制前三位为0的话会被判断为object类型，但null全部是0，所以typeof会返回object

2.['a']通常被称为键访问，.a通常被称为属性访问 

3.用 [] 包裹表达式当作属性名称为可计算属性名

4.Object.assign() 会遍历源对象所有可枚举的自有键并使用 = 操作符赋值到目标对象

​	所以源对象属性的一些特性（如writeable）不会被复制

5.对象的属性 其实有四个属性描述符

这四个统称为 数据描述符

getter setter 称为访问描述符

```js
var x = {y: 2}
Object.getOwnPropertyDescriptor(x,'y')
// 默认如下
{
    value: 2, 
    writable: true, 
    enumerable: true, 
    configurable: true
}
```


可以用 Object.defineProperty(x,'y',{...})

来定义或修改属性描述符

writable: 是否可以修改属性的值 

​	设置为false的话 非严格模式下静默失败 严格模式下将报错



configurable： 设置能否被配置 设置为false是单向操作 不可逆

​	但例外是 在false的情况下 能将 writable 由true改为false

​	false 的情况下 delete 也不能删掉这个属性

enumerable： 可枚举性 能否被 for in 访问到



6.禁止扩展

​	Object.preventExtensions(obj) 可以禁止对象添加新属性并保留旧属性

​	密封

​	Object.seal() 实际就是在上面的方法上 再将现有属性的configurable设置为false

​	冰冻

​	Object.freeze()

​	就是在Object.seal() 的基础上 再把 writable 设置为false

​	深度冻结

​	在上面的基础上 然后遍历他属性中引用的对象 对其使用Object.freeze()

7.[[Get]]

​	对象属性访问时 如果没找到名称相同的属性 会遍历可能存在的原型链 然后依旧没找到会返回 undefined

8.[[Put]]

​	对对象属性进行赋值或创建时 会进行以下判断

​	1.如果存在此属性，如果设置有setter就调用setter

​	2.看writable是否为false 是的话严格模式抛出typeerror 非严格模式下静默失败

​	如果都不是 就设置该值为属性的值

9. setter 和 getter （称为访问描述符）

   可以对属性设置了 set 和 get

   将会忽略 writable 和 value 描述符

   但是还是会关心 configurable 和 enumerable

```
var myObject = {
    get a() {
        return 2
    }
}
也可以在 defineProperty 里面定义
```



10. 存在性

    可以用 in 操作符

    “a” in myobject

    也可以用 myobject.hasOwnProperty("a")

    区别  in 会查找原型链 后者不会



11.枚举性

除了 for in

myobject.propertyIsEnumerable("a")

可以检查属性名是否直接(不查原型链)存在于对象上并且 enumerable是true



Object.keys() 会返回数组,包含可枚举的属性名

而 Object.getOwnPropertyNames()

会返回所有属性名 不管是否能枚举

这两个方法都不会查原型链



12.遍历

for in 不是在遍历值 而是遍历下标来指向值

因此for in 遍历对象的顺序无法确定的



foreach()遍历数组的值并忽略回调函数的返回值

every()会一直运行到返回false

some()会运行到返回true

[^2018年7月17日11:21:44 新增笔记]: find() 也是运行到返回true 并且会返回找到的元素



for of 实际会先向被访问对象申请一个迭代器对象

数组内置有@@iterator 因此可以直接 for of

```
//尝试自己手动遍历
var arr = [1,2,3]
var it = arr[Symbol.iterator]()
it.next()
it.next()
```

@@iterator 并不是一个迭代器对象 而是一个返回迭代器对象的函数

普通对象内部并没有@@iterator 所以无法遍历 但是map 和 set 可以



#### 4.混合对象“类”

简单来说 类的继承就是复制

js中进行继承或实例化的时候 js的对象机制并不会自动执行复制功能，因为js中只有对象，并不存在可以被实例化的“类”，一个对象并不会被复制到其他对象，而是被关联起来



js中有模拟类的复制行为 称为混入

js里使用多态的方法可以用call来显式指定this从而调用不同的函数 称为显式多态



#### 5.原型

1.属性设置与屏蔽

​	如果要访问的属性不在当前对象上而在原型链上的时候，会出现三种情况

​	一. 原型链上的属性 writable 不是 false 的话 会在当前对象新增此属性

​	二. 如果原型链上的该属性 writable 是false，则无法修改已有属性或者在当前对象上创建屏蔽属性，在非严格模式下赋值语句会被忽略 严格模式下将报错

​	如果要向对象添加此屏蔽属性 则不能使用 = 

​	可以使用 Object.defineProperty()

​	三. 上层存在属性 并且是个setter 时 一定会调用这个setter 



2.

```javascript
// 所谓的构造调用
function a () {
    this.s = 'b'; 
    sb = 'you'; 
    console.log(sb)
}

var b = new a()
console.log(b)

// console.log 会被打印 因为执行了函数a
// 而 this.s 由于 产生了 四种this绑定里的 new 绑定 绑定到了 新产生的对象 b里
// 所以 console.log(b) 结果是 {s: "b"}
// 如果  函数a里面return了一个对象 那b 就是return的内容
// 如果 a 不是return 的 对象 会被忽略
// 对于 b.constructor 能指向a函数 其实是因为 constructor 也是存在于 a.prototype上的
// b本身并没有constructor属性
// 如果 手动 将 a.prototype 指向空对象 那么 再 new 一个 b，b.constructor也找不到了


```

两种把 Bar.prototype 关联到 Foo.prototype上的方法对比

// es6 前的做法 这样会抛弃 bar原有的原型

Bar.prototype = Object.create(Foo.prototype)

// es6 开始可以直接修改现有的bar.prototype

Object.setPrototypeOf(Bar.prototype, Foo.prototype)



3. 检查“类”关系

在传统面向类环境中，检查一个实例的继承祖先通常被称为反射（或内省）

a instanceof  Foo 左边是一个普通对象 右边是一个函数

它回答的问题是 在a的原型链上是否有指向Foo.prototype的对象

只能用于处理 对象和函数之间的关系 不能判断两个对象之间是否通过原型链关联



有一种更简洁的方法 Foo.prototype.isPrototypeOf(a)

回答的是在a的原型链上是否出现过Foo.prototype

所以判断两个对象的关系也可以用 b.isPrototypeOf(a) b是否出现在a的原型链中



一个非标准的属性 \_\_proto\_\_ 可以获取对象的原型 

和 Object.getPrototyeOf(a) 得到的是一样的

和 .constructor 一样 他并不在对象上 在内置的Object.proptotype里 

虽然看起来是一个属性 

实际上更像一个get set 

get 部分可以看做就是调用  Object.getPrototyeOf

set 部分可以看做调用 Object.setPrototypeOf()





#### 6.行为委托

行为委托的核心就是 对象 用 Object.create() 与被委托的关联起来

书作者倡导的就是对象之间互相委托 将比使用类的设计模式更加灵活和简洁



#### 附录A ES6中的Class

实际上只是一种语法糖 是基于原型的实时委托

class 语法无法定义类成员属性 只能定义方法

要强行加类属性还是得用 .prototype

super() 并不是动态绑定的 是在声明是静态绑定的

并不是像this 找上一层的



toMethod() 会赋值一个方法 并把第一个参数当做原型链上层对象

第二个参数是新方法名 默认是原名



如果使用bind 函数来硬绑定函数 这个函数不会被extend到子类

[^笔记结束时间]: 2018年7月23日00:05:32
[^望常读常新]: 书名：你不知道的 JavaScript 上卷

























